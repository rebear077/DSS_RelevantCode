package main

import (
	"math"
	"math/rand"
	"time"
)

func APandTerminalMatch(TerminalPos, ApPos [][]float64) {
	/*	Input:
		TerminalPos: The set of terminal position coordinates generated by TerminalGenerate.m
		ApPos: The set of AP and satellite position coordinates generated by APGenerate.m and SatelliteGenerate.m
	*/
	APTerminalPairs := make(map[int][]int) // key: index of AP or satellite, value: the set of teminals connected to this AP of satellite
	for i := 0; i < len(TerminalPos); i++ {
		var maxDistance float64
		var res int
		rand.Seed(time.Now().UnixNano())
		// Generate a random decimal number between [0, 1).
		randomFloat := rand.Float64()
		time.Sleep(100 * time.Millisecond)
		if randomFloat < 0.5 {
			// Select a ground AP as the terminal's affiliation.
			// The closest distance criterion.
			for j := 0; j < len(ApPos); j = j + 2 {
				dis := math.Sqrt(math.Pow(TerminalPos[i][0]-ApPos[j][0], 2) + math.Pow(TerminalPos[i][1]-ApPos[j][1], 2) + math.Pow(TerminalPos[i][2]-ApPos[j][2], 2))
				if j == 0 {
					res = j
					maxDistance = dis
				} else if j > 0 {
					if dis < maxDistance {
						maxDistance = dis
						res = j
					}
				}
			}
		} else {
			// Select a satellite as the terminal's affiliation.
			// random choice
			rand.Seed(time.Now().UnixNano())
			time.Sleep(100 * time.Millisecond)
			randomInt := rand.Intn(len(ApPos)) + 1
			if randomInt%2 == 1 {
				res = randomInt
			} else {
				res = randomInt - 1
			}
		}
		APTerminalPairs[res] = append(APTerminalPairs[res], i) // Put the terminal's index into the map's value.
	}
}
